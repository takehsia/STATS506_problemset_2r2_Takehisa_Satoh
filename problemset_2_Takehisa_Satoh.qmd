---
title: "STATS506_Problemset2_Takehisa_Satoh"
format: pdf
editor: visual
---

# problem 1

# a.verstion 1 loop

```{r}
#function:perform the specified random walk
#Input: The number of steps
#Output:The final position of the walk
#       The Plot of a random walk trajectory

random_walk1 <- function(n){
  
  pos <- 0
  trace <- numeric(n+1)
  trace[1]<- pos
  
  for ( i in 1:n) {
  dir <- sample(c(1,-1),1)
  
  if (dir == 1){
    if (runif(1) < 0.05){
      pos <- pos + 10
    }
    else{ 
      pos <- pos + 1
    }
    }
  else{
    if (runif(1) < 0.2){
      pos <- pos - 3
      }else{
      pos <- pos -1 
      }
    }  
  
  trace [i+1]<- pos
  }
plot(0:n,trace,type="l", xlab="Step", ylab="Position",main =paste("Random Walk :Loop (n=",n,")"))
  return (pos) 
}

random_walk1(10)


```

# version2 vectorized function

```{r}
#function:perform the specified random walk
#Input: The number of steps
#Output:The final position of the walk
#       The Plot of a random walk trajectory

random_walk2 <- function(n){
  dir <- sample(c(1,-1),n, replace=TRUE)
  rnd_plus <- runif(n)
  rnd_minus <-runif(n)
  
  steps <-ifelse(
    dir == 1,
    ifelse(rnd_plus<0.05,10,1),
    ifelse(rnd_minus<0.2,-3,-1)
  ) 
  
  pos_trace <- c(0,cumsum(steps))
  
  plot(0:n,pos_trace,type="l",xlab="Step",ylab="Position",main=paste("Random Walk :Vectorize (n=",n,")"))

  return(pos_trace[n])
    
}

random_walk2(10)
```

# a.version3 apply function

```{r}
#function:perform the specified random walk
#Input: The number of steps
#Output:The final position of the walk
#       The Plot of a random walk trajectory

random_walk3 <- function(n) {
  steps <- sapply(1:n,function(i){
    dir<- sample(c(1,-1), 1)
    if(dir==1){
     if (runif(1)<0.05){
       10
      }else{
        1
      }
    }else{
      if (runif(1)<0.2){
        -3
        }else{
          -1
        }
       }
      })
  trace_step<- c(0,cumsum(steps))    

  plot(0:n,trace_step,type="l",xlab="Steps", ylab="Postion",main =paste("Randam Walk:Apply function (n=",n,")"))
  
  return(trace_step[n])
  
  }
  
random_walk3(10)

```

```{r}
random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)
```

# b

```{r}

# function: Generates and returns the sequence of "random" choices for all steps
# inputs:
#   n   : number of steps (integer)
# output:
#   list of
#     dir_vec: vector of +1 or -1 (direction per step)
#     rnd_plus_vec: vector of runif values for positive steps (each step, even if not used)
#     rnd_minus_vec: vector of runif values for negative steps (each step, even if not used)

generate_random_series <- function(n){
  dir_vec <- sample(c(1,-1), n, replace=TRUE)
  rnd_plus_vec <- runif(n)
  rnd_minus_vec <- runif(n)
  list(dir_vec=dir_vec, rnd_plus_vec=rnd_plus_vec, rnd_minus_vec=rnd_minus_vec)
}

# function: Uses provided random vectors to perform the walk and record the trace (loop version).
# inputs:
#   n            : number of steps (integer)
#   dir_vec      : vector of directions, length n
#   rnd_plus_vec : vector of runif values, for positive direction, length n
#   rnd_minus_vec: vector of runif values, for negative direction, length n
# output:
#   list with final position, and trace

random_walk_b1 <- function(n, dir_vec, rnd_plus_vec, rnd_minus_vec){
  pos <- 0

  for(i in 1:n){
    if(dir_vec[i] == 1){
      if(rnd_plus_vec[i] < 0.05){
        pos <- pos + 10
      } else {
        pos <- pos + 1
      }
    } else {
      if(rnd_minus_vec[i] < 0.2){
        pos <- pos - 3
      } else {
        pos <- pos - 1
      }
    }
    }

    return(pos)
}

# function: Uses provided random vectors to perform the walk and record the trace (vectorized version).
# inputs:
#   n            : number of steps (integer)
#   dir_vec      : vector of directions, length n
#   rnd_plus_vec : vector of runif values, for positive direction, length n
#   rnd_minus_vec: vector of runif values, for negative direction, length n
# output:
#   list with final position, and trace

random_walk_b2 <- function(n, dir_vec, rnd_plus_vec, rnd_minus_vec){
  steps <- ifelse(
    dir_vec == 1,
    ifelse(rnd_plus_vec<0.05, 10, 1),
    ifelse(rnd_minus_vec<0.2, -3, -1)
  ) 
  pos_trace <- c(0, cumsum(steps))

    return(pos_trace[n+1])  
}

# function: Uses provided random vectors to perform the walk and record the trace (apply version).
# inputs:
#   n            : number of steps (integer)
#   dir_vec      : vector of directions, length n
#   rnd_plus_vec : vector of runif values, for positive direction, length n
#   rnd_minus_vec: vector of runif values, for negative direction, length n
# output:
#   list with final position, and trace

random_walk_b3 <- function(n, dir_vec, rnd_plus_vec, rnd_minus_vec) {
  steps <- sapply(1:n, function(i){
    if(dir_vec[i] == 1){
      if (rnd_plus_vec[i] < 0.05){
        10
      } else {
        1
      }
    } else {
      if (rnd_minus_vec[i] < 0.2){
        -3
      } else {
        -1
      }
    }
  })
  trace_step <- c(0, cumsum(steps))    

    return(trace_step[n+1])
}
```

```{r}
n <- 10
rand_dat <- generate_random_series(n)

random_walk_b1(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)
random_walk_b2(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)
random_walk_b3(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)

n <- 100
rand_dat <- generate_random_series(n)

random_walk_b1(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)
random_walk_b2(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)
random_walk_b3(n, rand_dat$dir_vec, rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec)

```

# c
# the function of vectorized version is the fastest.
```{r}
library(microbenchmark)
```

```{r}
benchmark <- function(n){
  rand_dat <- generate_random_series(n)
  microbenchmark(
  b1 = random_walk_b1(n,rand_dat$dir_vec,rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec),
  b2 = random_walk_b2(n,rand_dat$dir_vec,rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec),
  b3 = random_walk_b3(n,rand_dat$dir_vec,rand_dat$rnd_plus_vec, rand_dat$rnd_minus_vec),
  times = 10L
  )
}

benchmark(1000)

benchmark(1000000)


```

# d
# answer n=10:the probability is 0.13135, n=100:the probability is 0.02022, n=1000:the probability is 0.00577
```{r}
estimate_zero_probability <- function(n, sims = 1e5){
  random_walk_d2 <- function(n){
    dirs <- sample(c(1, -1), n, replace = TRUE)
    rnd_plus  <- runif(n)
    rnd_minus <- runif(n)
    steps <- ifelse(
      dirs == 1,
      ifelse(rnd_plus < 0.05, 10, 1),
      ifelse(rnd_minus < 0.20, -3, -1)
    )
    sum(steps)
  }
  results <- replicate(sims,random_walk_d2(n))
  prob <- mean(results == 0)
  return(prob)
}

p10 <- estimate_zero_probability(10)
p100 <- estimate_zero_probability(100)
p1000 <- estimate_zero_probability(1000)

p10
p100
p1000

```

# Problem 2
```{r}
sims <- 1000

hours_type <- c(
rep(1,8), #0:00~7:59
2,        #8:00~8:59
rep(3,8), #9:00~16:59
4,        #17:00~17:59  
rep(5,6)   #18:00~23:59
)

# function: Generate simulated hourly car counts for the given hour according to the specified distribution type.
  # input:
  #   h - integer from 1 to 24 indicating the hour of the day
  #   (uses hours_type[h] to determine which distribution is used for this hour)
  #   sims - number of Monte Carlo simulations per hour (should be defined outside)
#output: A matrix of size sims x 24, each entry is the simulated number of cars for that simulation and hour.

hours_matrix <- sapply(1:24,function(h){
  if(hours_type[h] == 1){
    rpois(sims,1)
  }else if(hours_type[h] == 2){
    round(rnorm(sims, mean=60,sd=sqrt(12)))
  }else if(hours_type[h] == 3){
    rpois(sims,8)
  }else if(hours_type[h] == 4){
    round(rnorm(sims, mean=60,sd=sqrt(12)))
  }else{
    rpois(sims,12)
  }
}
)

daily_total <-rowSums(hours_matrix)
mean(daily_total)

```

# Problem 3
# a
# the dimensions of the data after removing columns which identify a commercial: 247 X 20
```{r}
youtube <- read.csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-03-02/youtube.csv')

```

```{r}
youtube_deindentification <- youtube[,!names(youtube) %in%  c("brand","	superbowl_ads_dot_com_url","youtube_url","published_at","title","description")]

print(dim(youtube_deindentification))

```

# b
# answer:
# View counts:Category ii
# Like counts:Category ii
# Dislike counts:Category iii
# Favorite counts:Category ii
# Comment counts:Category ii

```{r}
vars <- c("view_count", "like_count", "dislike_count", "favorite_count", "comment_count")

summary(youtube[vars])

par(mfrow = c(2, 3))
for(v in vars){
  hist(na.omit(youtube[[v]]),
       main = v,
       xlab = "",
       breaks = 10)
}

```

```{r}
par(mfrow = c(2,3))
for(v in vars){
  hist(log1p(na.omit(youtube[[v]])),
       main = v,
       xlab = "",
       breaks = 10)
  }

```

```{r}
#add log tarnsformation of "view_count", "like_count", "comment_count"

youtube$log_view_count <- log1p(youtube$view_count)
youtube$log_like_count <- log1p(youtube$like_count)
youtube$log_dislike_count <- log1p(youtube$dislike_count)
youtube$log_comment_count <- log1p(youtube$comment_count)

```

# https://bioinfo-dojo.net/2017/08/09/r-cumsum/ helped me figure out some functions.

```{r}


## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
